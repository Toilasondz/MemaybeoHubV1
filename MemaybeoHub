local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- TR·∫†NG TH√ÅI T√çNH NƒÇNG
local AIMBOT_ENABLED = false
local ESP_ENABLED = false
local ESPLINE_ENABLED = false
local FOV_ENABLED = false
local TEAMCHECK_ENABLED = false
local RAINBOW_FOV_ENABLED = false 
local GUI_CLOSED = false

--== C√ÄI ƒê·∫∂T M√ÄU S·∫ÆC ==--
local ENEMY_COLOR = Color3.fromRGB(255, 255, 255)        -- TR·∫ÆNG (Cho ESP Box v√† Line)
local TEAM_COLOR = Color3.fromRGB(0, 255, 0)             -- XANH L√Å
local FOV_COLOR = Color3.fromRGB(0, 255, 0)              -- XANH L√Å C√ÇY (M·∫∑c ƒë·ªãnh)
local INDEX_COLOR_ENEMY = Color3.fromRGB(255, 0, 0)      -- ƒê·ªé (Cho Index Text c·ªßa Enemy)
local SLIDER_COLOR = Color3.fromRGB(0, 255, 0)           -- M√ÄU XANH L√Å C√ÇY CHO SLIDER

--== C√ÄI ƒê·∫∂T FOV M·ªöI ==--
local FOV_MIN = 30
local FOV_MAX = 500
local FOV_RADIUS_VALUE = 90 -- Gi√° tr·ªã FOV m·∫∑c ƒë·ªãnh v√† c√≥ th·ªÉ thay ƒë·ªïi

--== GUI & DRAWING DEFINITIONS ==--
local ScreenGui, Frame, ToggleBtn
local BtnToggleAimbot, BtnToggleESP, BtnToggleESPLines, BtnToggleFOV, BtnToggleTeamCheck, BtnToggleRainbowFOV, CloseBtn -- [UPDATED]
local CustomCopyBtn
local Notification
local PlayerCountLabel
local FPSMover

-- [NEW SLIDER ELEMENTS]
local FovSliderLabel
local SliderContainer
local SliderTrack
local SliderFill
local SliderThumb

--== GLOBAL DRAG STATE ==--
local isDraggingSlider = false -- Bi·∫øn to√†n c·ª•c theo d√µi tr·∫°ng th√°i k√©o (HOLD state)

--== FOV SETUP ==--
local fovCircle
do
    local success, circle = pcall(function() return Drawing.new("Circle") end)
    if success and circle then
        fovCircle = circle
        fovCircle.Visible = false
        fovCircle.Radius = FOV_RADIUS_VALUE -- S·ª≠ d·ª•ng bi·∫øn m·ªõi
        fovCircle.Thickness = 2
        fovCircle.Color = FOV_COLOR
        fovCircle.Filled = false
    else
        fovCircle = nil
    end
end

--== ESP SETUP ==--
local ESPs = {}

local function createESP(plr)
    if not plr or plr == LocalPlayer then return end
    if ESPs[plr] then return end

    local successBox, box = pcall(function() return Drawing.new("Square") end)
    local successLine, line = pcall(function() return Drawing.new("Line") end)
    local successText, text = pcall(function() return Drawing.new("Text") end)

    ESPs[plr] = {
        Box = successBox and box or nil,
        Line = successLine and line or nil,
        IndexText = successText and text or nil
    }

    if ESPs[plr].Box then
        ESPs[plr].Box.Visible = false
        ESPs[plr].Box.Thickness = 1
        ESPs[plr].Box.Filled = false
        ESPs[plr].Box.Color = ENEMY_COLOR -- TR·∫ÆNG
    end
    if ESPs[plr].Line then
        ESPs[plr].Line.Visible = false
        ESPs[plr].Line.Thickness = 1
        ESPs[plr].Line.Color = ENEMY_COLOR -- TR·∫ÆNG
    end
    if ESPs[plr].IndexText then
        ESPs[plr].IndexText.Visible = false
        ESPs[plr].IndexText.Size = 48 -- TƒÉng k√≠ch th∆∞·ªõc Index Text ƒë·ªÉ n·ªïi b·∫≠t h∆°n
        ESPs[plr].IndexText.Outline = true
        ESPs[plr].IndexText.Color = INDEX_COLOR_ENEMY -- ƒê·ªé
        ESPs[plr].IndexText.Text = "üéØ" -- Bi·ªÉu t∆∞·ª£ng m·ª•c ti√™u
    end
end

for _, p in ipairs(Players:GetPlayers()) do
    createESP(p)
end
Players.PlayerAdded:Connect(createESP)
Players.PlayerRemoving:Connect(function(plr)
    local data = ESPs[plr]
    if data then
        if data.Box then pcall(function() data.Box:Remove() end) end
        if data.Line then pcall(function() data.Line:Remove() end) end
        if data.IndexText then pcall(function() data.IndexText:Remove() end) end
        ESPs[plr] = nil
    end
end)

-- [Core Functions: isVisible, getClosestToFOV, ToggleBlur, showNotification]

local function isVisible(part)
    if not part then return false end
    local origin = Camera and Camera.CFrame.Position or Workspace.CurrentCamera.CFrame.Position
    local dir = (part.Position - origin)
    if dir.Magnitude == 0 then return true end
    -- C·ªë g·∫Øng s·ª≠ d·ª•ng Raycasting m·ªõi n·∫øu c√≥ (ch·ªâ gi·ªØ l·∫°i b·∫£n c≈© cho t√≠nh t∆∞∆°ng th√≠ch)
    local ray = Ray.new(origin, dir.Unit * math.clamp(dir.Magnitude, 1, 1000))
    local hit, hitPos = Workspace:FindPartOnRay(ray, LocalPlayer.Character, false, true)
    return hit and hit:IsDescendantOf(part.Parent)
end

local function getClosestToFOV()
    -- H√†m n√†y s·∫Ω t√¨m ng∆∞·ªùi ch∆°i g·∫ßn t√¢m FOV nh·∫•t
    local closest, dist = nil, math.huge
    local currentFovRadius = FOV_RADIUS_VALUE -- S·ª≠ d·ª•ng gi√° tr·ªã FOV hi·ªán t·∫°i

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
            -- B·ªè qua ƒë·ªìng ƒë·ªôi n·∫øu TeamCheck ON
            if TEAMCHECK_ENABLED and plr.Team and LocalPlayer.Team and plr.Team == LocalPlayer.Team then
                continue
            end
            local head = plr.Character.Head
            local vec, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                local mag = (Vector2.new(vec.X, vec.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                -- Ki·ªÉm tra d·ª±a tr√™n gi√° tr·ªã FOV hi·ªán t·∫°i
                if mag < currentFovRadius and mag < dist then
                    if isVisible(head) then
                        closest = plr -- Tr·∫£ v·ªÅ Player, kh√¥ng ph·∫£i Head
                        dist = mag
                    end
                end
            end
        end
    end
    return closest
end

local blur = Instance.new("BlurEffect")
blur.Size = 0
blur.Parent = Lighting

local function ToggleBlur(state)
    TweenService:Create(
        blur,
        TweenInfo.new(0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
        {Size = state and 14 or 0}
    ):Play()
end

function showNotification(msg)
    if GUI_CLOSED then return end
    if not Notification or not Notification.Parent then pcall(buildGUI) end
    if not Notification then return end
    Notification.Text = msg
    Notification.Visible = true
    task.delay(2, function()
        if Notification then Notification.Visible = false end
    end)
end

-- H√†m chuy·ªÉn ƒë·ªïi t·ª´ HSV sang Color3
local function colorFromHSV(h, s, v)
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    local r, g, b
    
    if i % 6 == 0 then r, g, b = v, t, p
    elseif i % 6 == 1 then r, g, b = q, v, p
    elseif i % 6 == 2 then r, g, b = p, v, t
    elseif i % 6 == 3 then r, g, b = p, q, v
    elseif i % 6 == 4 then r, g, b = t, p, v
    elseif i % 6 == 5 then r, g, b = v, p, q
    end
    
    return Color3.new(r, g, b)
end


--== LOGIC THANH K√âO FOV (GI·ªÆ V√Ä K√âO) ==--

-- H√†m √°nh x·∫° gi√° tr·ªã FOV (MIN-MAX) th√†nh t·ªâ l·ªá (0-1)
local function getFovRatio()
    return math.min(1, math.max(0, (FOV_RADIUS_VALUE - FOV_MIN) / (FOV_MAX - FOV_MIN)))
end

-- H√†m c·∫≠p nh·∫≠t v·ªã tr√≠ thanh k√©o v√† gi√° tr·ªã FOV
local function updateFovSlider(newRatio)
    local ratio = math.min(1, math.max(0, newRatio))
    
    -- T√≠nh gi√° tr·ªã FOV m·ªõi
    local newFov = math.round(FOV_MIN + (FOV_MAX - FOV_MIN) * ratio)
    
    -- C·∫≠p nh·∫≠t bi·∫øn to√†n c·ª•c
    FOV_RADIUS_VALUE = newFov
    if fovCircle then
        fovCircle.Radius = newFov
    end

    -- C·∫≠p nh·∫≠t GUI (ƒê√£ d·ªãch sang Ti·∫øng Vi·ªát)
    if FovSliderLabel then
        FovSliderLabel.Text = "B√°n k√≠nh FOV: " .. tostring(newFov) -- D·ªãch
    end
    
    if SliderTrack and SliderFill and SliderThumb then
        -- C·∫ßn l·∫•y k√≠ch th∆∞·ªõc Track sau khi GUI ƒë√£ ƒë∆∞·ª£c render
        local trackWidth = SliderTrack.AbsoluteSize.X
        
        -- C·∫≠p nh·∫≠t thanh ƒëi·ªÅn (Fill)
        SliderFill.Size = UDim2.new(ratio, 0, 1, 0)
        
        -- C·∫≠p nh·∫≠t v·ªã tr√≠ n√∫m k√©o (Thumb)
        -- V·ªã tr√≠ Thumb = T·ªâ l·ªá * Chi·ªÅu r·ªông Track - N·ª≠a chi·ªÅu r·ªông c·ªßa Thumb
        local thumbWidth = SliderThumb.AbsoluteSize.X
        local thumbX = (ratio * trackWidth) - (thumbWidth / 2)
        SliderThumb.Position = UDim2.new(0, thumbX, 0.5, 0)
    end
end

-- X·ª≠ l√Ω k√©o (Ch·∫°y li√™n t·ª•c khi chu·ªôt di chuy·ªÉn v√† ƒëang ·ªü tr·∫°ng th√°i k√©o)
local function handleSliderDrag(input)
    if GUI_CLOSED or not SliderTrack or not isDraggingSlider then return end
    
    -- L·∫•y v·ªã tr√≠ chu·ªôt trong kh√¥ng gian tuy·ªát ƒë·ªëi c·ªßa thanh k√©o
    local trackAbsPos = SliderTrack.AbsolutePosition
    local trackAbsSize = SliderTrack.AbsoluteSize
    
    -- S·ª≠ d·ª•ng input.Position.X ƒë·ªÉ l·∫•y t·ªça ƒë·ªô X c·ªßa chu·ªôt
    local mouseX = input.Position.X 
    
    -- T√≠nh to√°n v·ªã tr√≠ X c·ªßa chu·ªôt so v·ªõi ƒëi·ªÉm g·ªëc c·ªßa Track
    local xOffset = mouseX - trackAbsPos.X
    
    -- T√≠nh to√°n t·ªâ l·ªá m·ªõi (0 ƒë·∫øn 1)
    local newRatio = xOffset / trackAbsSize.X
    
    -- C·∫≠p nh·∫≠t thanh k√©o v√† gi√° tr·ªã FOV
    updateFovSlider(newRatio)
end

-- B∆Ø·ªöC 2: K√©o li√™n t·ª•c (DRAG)
-- Tr√¨nh l·∫Øng nghe to√†n c·ª•c cho MouseMovement, ch·ªâ ho·∫°t ƒë·ªông n·∫øu isDraggingSlider = true
UserInputService.InputChanged:Connect(function(input)
    if isDraggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then
        -- V·∫´n ki·ªÉm tra xem Frame c√≥ hi·ªÉn th·ªã kh√¥ng ƒë·ªÉ tr√°nh k√©o trong khi menu ƒë√≥ng
        if Frame and Frame.Visible then
            handleSliderDrag(input)
        end
    end
end)

-- B∆Ø·ªöC 3: D·ª´ng k√©o (RELEASE)
-- Tr√¨nh l·∫Øng nghe to√†n c·ª•c cho InputEnded, ƒë·∫∑t l·∫°i tr·∫°ng th√°i k√©o
UserInputService.InputEnded:Connect(function(input)
    -- D·ª´ng k√©o ngay khi nh·∫£ chu·ªôt (MouseButton1) ·ªü b·∫•t c·ª© ƒë√¢u tr√™n m√†n h√¨nh
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isDraggingSlider = false
    end
end)


--== GUI BUILDER FUNCTION ==--
local function updateButtonText(btn, featureName, isEnabled, icon)
    local status = isEnabled and "B·∫¨T" or "T·∫ÆT"
    btn.Text = featureName .. ": " .. status .. " " .. icon
end

local function buildGUI()
    if ScreenGui and ScreenGui.Parent then
        if not ToggleBtn.Parent then ToggleBtn.Parent = ScreenGui end
        if not FPSMover.Parent then FPSMover.Parent = ScreenGui end
        return
    end

    ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "MeMayBeo Hub"
    ScreenGui.ResetOnSpawn = false

    -- 0. FPS MOVER (NEW: Ph·∫ßn t·ª≠ ƒë·ªôc l·∫≠p, c√≥ th·ªÉ k√©o th·∫£)
    FPSMover = Instance.new("TextLabel", ScreenGui)
    FPSMover.Size = UDim2.new(0, 80, 0, 20)
    FPSMover.Position = UDim2.new(1, -90, 0, 10) -- G√≥c tr√™n b√™n ph·∫£i
    FPSMover.BackgroundTransparency = 0.8
    FPSMover.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    FPSMover.Text = "[FPS: N/A]"
    FPSMover.TextColor3 = Color3.fromRGB(255, 255, 255)
    FPSMover.Font = Enum.Font.SourceSansBold
    FPSMover.TextSize = 14
    FPSMover.Active = true
    FPSMover.Draggable = true
    FPSMover.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh

    local fpsCorner = Instance.new("UICorner", FPSMover)
    fpsCorner.CornerRadius = UDim.new(0, 5)

    -- 1. N√öT M·ªû/ƒê√ìNG MENU (ToggleBtn)
    ToggleBtn = Instance.new("TextButton", ScreenGui)
    ToggleBtn.Size = UDim2.new(0, 30, 0, 30)
    ToggleBtn.Position = UDim2.new(0, 10, 0, 10)
    ToggleBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    ToggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleBtn.Font = Enum.Font.SourceSansBold
    ToggleBtn.TextSize = 20
    ToggleBtn.Text = "„äé"
    ToggleBtn.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh

    local cornerToggle = Instance.new("UICorner", ToggleBtn)
    cornerToggle.CornerRadius = UDim.new(0, 5)

    -- Logic K√©o th·∫£ cho ToggleBtn
    local draggingBtn = false
    local dragStartBtn
    local startPosBtn

    ToggleBtn.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            draggingBtn = true
            dragStartBtn = input.Position
            startPosBtn = ToggleBtn.Position
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            draggingBtn = false
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if draggingBtn and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStartBtn
            ToggleBtn.Position = UDim2.new(
                startPosBtn.X.Scale,
                startPosBtn.X.Offset + delta.X,
                startPosBtn.Y.Scale,
                startPosBtn.Y.Offset + delta.Y
            )
        end
    end)


    -- 2. FRAME CH√çNH (Menu)
    -- K√≠ch th∆∞·ªõc 450x360
    local FRAME_WIDTH = 450
    local FRAME_HEIGHT = 360
    Frame = Instance.new("Frame", ScreenGui)
    Frame.Size = UDim2.new(0, FRAME_WIDTH, 0, FRAME_HEIGHT) 
    Frame.Position = UDim2.new(0.5, -FRAME_WIDTH/2, 0.5, -FRAME_HEIGHT/2) -- CƒÉn gi·ªØa m√†n h√¨nh m·ªõi
    Frame.BackgroundColor3 = Color3.fromRGB(40,40,40)
    Frame.BackgroundTransparency = 0.25
    Frame.Active = true
    Frame.Draggable = true
    Frame.Visible = false
    Frame.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh

    local corner = Instance.new("UICorner", Frame)
    corner.CornerRadius = UDim.new(0, 14)

    local gradient = Instance.new("UIGradient", Frame)
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(40,40,40)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(25,25,25))
    }
    gradient.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.15),
        NumberSequenceKeypoint.new(1, 0.25)
    }

    local TitleBar = Instance.new("TextLabel", Frame)
    TitleBar.Size = UDim2.new(1, 0, 0, 40)
    TitleBar.BackgroundColor3 = Color3.fromRGB(25,25,25)
    TitleBar.Text = "MeMayBeo Hub" -- D·ªãch Title
    TitleBar.TextColor3 = Color3.fromRGB(255,255,255)
    TitleBar.Font = Enum.Font.SourceSansBold
    TitleBar.TextSize = 29
    TitleBar.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh

    local InfoLabel1 = Instance.new("TextLabel", Frame)
    InfoLabel1.Size = UDim2.new(1, -20, 0, 20)
    InfoLabel1.Position = UDim2.new(0, 10, 0, 40)
    InfoLabel1.BackgroundTransparency = 1
    InfoLabel1.Text = "Tik Tok @hoangvanson_9k"
    InfoLabel1.TextColor3 = Color3.fromRGB(200,200,200)
    InfoLabel1.Font = Enum.Font.SourceSansItalic
    InfoLabel1.TextSize = 20
    InfoLabel1.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh

    local InfoLabel2 = Instance.new("TextLabel", Frame)
    InfoLabel2.Size = UDim2.new(1, -20, 0, 20)
    InfoLabel2.Position = UDim2.new(0, 10, 0, 55)
    InfoLabel2.BackgroundTransparency = 1
    InfoLabel2.Text = "MeMayBeo Hub by @hoangvanson_9k"
    InfoLabel2.TextColor3 = Color3.fromRGB(200,200,200)
    InfoLabel2.Font = Enum.Font.SourceSansItalic
    InfoLabel2.TextSize = 20
    InfoLabel2.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh

    PlayerCountLabel = Instance.new("TextLabel", Frame)
    PlayerCountLabel.Size = UDim2.new(1, -20, 0, 20)
    PlayerCountLabel.Position = UDim2.new(0, 10, 0, 75)
    PlayerCountLabel.BackgroundTransparency = 1
    PlayerCountLabel.Text = "Ng∆∞·ªùi ch∆°i hi·ªÉn th·ªã: 0" -- D·ªãch
    PlayerCountLabel.TextColor3 = Color3.fromRGB(255,255,255)
    PlayerCountLabel.Font = Enum.Font.SourceSansBold
    PlayerCountLabel.TextSize = 16
    PlayerCountLabel.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh


    local function createButton(text, posY, posX, width, color)
        local btn = Instance.new("TextButton", Frame)
        btn.Size = UDim2.new(0, width or 200, 0, 30)
        btn.Position = UDim2.new(0, posX or 20, 0, posY)
        btn.Text = text
        btn.BackgroundColor3 = color or Color3.fromRGB(60,60,60)
        btn.TextColor3 = Color3.fromRGB(255,255,255)
        btn.Font = Enum.Font.SourceSansBold
        btn.TextSize = 16
        btn.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn cho n√∫t
        local btnCorner = Instance.new("UICorner", btn)
        btnCorner.CornerRadius = UDim.new(0, 8)
        return btn
    end
    
    -- V·ªã tr√≠ b·∫Øt ƒë·∫ßu c·ªßa c√°c n√∫t ch·ª©c nƒÉng
    local START_Y = 100
    local COLUMN_1_X = 20
    local COLUMN_2_X = 230
    local BUTTON_WIDTH = 200
    local BUTTON_SPACING = 40 -- Chi·ªÅu cao n√∫t + kho·∫£ng c√°ch = 30 + 10

    -- COLUMN 1 (ƒê√£ d·ªãch v√† th√™m icon)
    BtnToggleAimbot = createButton("", START_Y, COLUMN_1_X, BUTTON_WIDTH)
    updateButtonText(BtnToggleAimbot, "Aim", AIMBOT_ENABLED, "üî´")

    BtnToggleESP = createButton("", START_Y + BUTTON_SPACING, COLUMN_1_X, BUTTON_WIDTH)
    updateButtonText(BtnToggleESP, "ƒê·ªãnh V·ªã H·ªôp", ESP_ENABLED, "üî≤")

    BtnToggleFOV = createButton("", START_Y + BUTTON_SPACING*2, COLUMN_1_X, BUTTON_WIDTH)
    updateButtonText(BtnToggleFOV, "Hi·ªÉn th·ªã FOV", FOV_ENABLED, "‚≠ï")
    
    -- COLUMN 2 (ƒê√£ d·ªãch v√† th√™m icon)
    BtnToggleESPLines = createButton("", START_Y, COLUMN_2_X, BUTTON_WIDTH)
    updateButtonText(BtnToggleESPLines, "ƒê·ªãnh V·ªã ƒê∆∞·ªùng", ESPLINE_ENABLED, "‡πÄ‡∏™‡πâ‡∏ô") -- D√πng icon ƒë·∫∑c bi·ªát cho ƒë∆∞·ªùng line

    BtnToggleTeamCheck = createButton("", START_Y + BUTTON_SPACING, COLUMN_2_X, BUTTON_WIDTH)
    updateButtonText(BtnToggleTeamCheck, "B·ªè qua ƒë·ªìng ƒë·ªôi", TEAMCHECK_ENABLED, "ü§ù")

    BtnToggleRainbowFOV = createButton("", START_Y + BUTTON_SPACING*2, COLUMN_2_X, BUTTON_WIDTH)
    updateButtonText(BtnToggleRainbowFOV, "Fov C·∫ßu V√≤ng", RAINBOW_FOV_ENABLED, "üåà") 
    
    -- V·ªã tr√≠ ti·∫øp theo sau 2 c·ªôt
    local NEXT_Y = START_Y + BUTTON_SPACING*3 + 5 -- B·∫Øt ƒë·∫ßu t·ª´ 220, tƒÉng th√™m 5px ƒë·ªÉ t·∫°o kho·∫£ng c√°ch

    --== THANH K√âO FOV (TO√ÄN B·ªò CHI·ªÄU R·ªòNG) ==--
    
    -- 1. Label hi·ªÉn th·ªã gi√° tr·ªã FOV (ƒê√£ d·ªãch)
    FovSliderLabel = Instance.new("TextLabel", Frame)
    FovSliderLabel.Size = UDim2.new(1, -20, 0, 20)
    FovSliderLabel.Position = UDim2.new(0, 10, 0, NEXT_Y) 
    FovSliderLabel.BackgroundTransparency = 1
    FovSliderLabel.Text = "FOV: " .. tostring(FOV_RADIUS_VALUE)
    FovSliderLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    FovSliderLabel.Font = Enum.Font.SourceSansBold
    FovSliderLabel.TextSize = 16
    FovSliderLabel.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh
    
    -- 2. Container cho Slider
    local SLIDER_Y = NEXT_Y + 25
    local SLIDER_WIDTH = FRAME_WIDTH - 40
    SliderContainer = Instance.new("Frame", Frame)
    SliderContainer.Size = UDim2.new(0, SLIDER_WIDTH, 0, 20)
    SliderContainer.Position = UDim2.new(0, 20, 0, SLIDER_Y) 
    SliderContainer.BackgroundTransparency = 1
    SliderContainer.Active = true 
    SliderContainer.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh
    
    -- 3. Track (N·ªÅn ƒëen)
    SliderTrack = Instance.new("Frame", SliderContainer)
    SliderTrack.Size = UDim2.new(1, 0, 0, 8)
    SliderTrack.Position = UDim2.new(0, 0, 0.5, -4)
    SliderTrack.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    SliderTrack.Active = true 
    SliderTrack.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh
    
    local trackCorner = Instance.new("UICorner", SliderTrack)
    trackCorner.CornerRadius = UDim.new(0, 4)
    
    -- 4. Fill (Ph·∫ßn ƒë√£ ƒëi·ªÅn, m√†u xanh l√° c√¢y)
    SliderFill = Instance.new("Frame", SliderTrack)
    SliderFill.Size = UDim2.new(getFovRatio(), 0, 1, 0) -- Kh·ªüi t·∫°o Fill theo gi√° tr·ªã FOV hi·ªán t·∫°i
    SliderFill.Position = UDim2.new(0, 0, 0, 0)
    SliderFill.BackgroundColor3 = SLIDER_COLOR
    SliderFill.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh
    
    local fillCorner = Instance.new("UICorner", SliderFill)
    fillCorner.CornerRadius = UDim.new(0, 4)

    -- 5. Thumb (N√∫t k√©o, h√¨nh tr√≤n m√†u tr·∫Øng)
    SliderThumb = Instance.new("ImageLabel", SliderContainer)
    SliderThumb.Size = UDim2.new(0, 16, 0, 16)
    SliderThumb.Image = "rbxassetid://6250275811" -- Icon h√¨nh tr√≤n tr·∫Øng
    SliderThumb.BackgroundTransparency = 1
    SliderThumb.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    SliderThumb.Active = true 
    SliderThumb.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh
    
    local thumbCorner = Instance.new("UICorner", SliderThumb)
    thumbCorner.CornerRadius = UDim.new(0.5, 0) -- L√†m cho n√≥ tr√≤n
    
    -- Kh·ªüi t·∫°o v·ªã tr√≠ ban ƒë·∫ßu c·ªßa Thumb
    updateFovSlider(getFovRatio())

    -- B∆Ø·ªöC 1: B·∫ÆT ƒê·∫¶U K√âO (HOLD)
    local function startDragging(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDraggingSlider = true -- K√≠ch ho·∫°t tr·∫°ng th√°i k√©o
            handleSliderDrag(input) -- C·∫≠p nh·∫≠t ngay khi click ƒë·ªÉ b·∫Øt ƒë·∫ßu k√©o
        end
    end

    -- B·∫Øt ƒë·∫ßu k√©o khi nh·∫•p v√†o Thumb
    SliderThumb.InputBegan:Connect(startDragging)
    -- B·∫Øt ƒë·∫ßu k√©o khi nh·∫•p v√†o Track (k·ªÉ c·∫£ Fill)
    SliderTrack.InputBegan:Connect(startDragging)
    
    -- C·∫≠p nh·∫≠t v·ªã tr√≠ c√°c n√∫t cu·ªëi (To√†n b·ªô chi·ªÅu r·ªông Frame)
    local FOOTER_Y = SLIDER_Y + 35
    
    CustomCopyBtn = createButton("CLICK N·∫æU B·∫†N ƒê·∫∏P TRAI", FOOTER_Y, COLUMN_1_X, SLIDER_WIDTH, Color3.fromRGB(50, 150, 255)) 
    CustomCopyBtn.TextSize = 18
    
    CloseBtn = createButton("ƒê√ìNG MENU", FOOTER_Y + BUTTON_SPACING, COLUMN_1_X, SLIDER_WIDTH, Color3.fromRGB(150,50,50)) -- D·ªãch

    -- 3. NOTIFICATION
    Notification = Instance.new("TextLabel", ScreenGui)
    Notification.Size = UDim2.new(0,200,0,30)
    Notification.Position = UDim2.new(1,-210,1,-40)
    Notification.BackgroundTransparency = 0.3
    Notification.BackgroundColor3 = Color3.fromRGB(20,20,20)
    Notification.TextColor3 = Color3.fromRGB(255,255,255)
    Notification.TextScaled = true
    Notification.Visible = false
    Notification.BorderSizePixel = 0 -- ƒê√É TH√äM: Lo·∫°i b·ªè vi·ªÅn m·∫∑c ƒë·ªãnh

    -- [Event Handlers]
    ToggleBtn.MouseButton1Click:Connect(function()
        if GUI_CLOSED then return end
        Frame.Visible = not Frame.Visible
        ToggleBlur(Frame.Visible)
    end)

    CustomCopyBtn.MouseButton1Click:Connect(function()
        local textToCopy = "@hoangvanson_9k"
        local copySuccessful = false
        pcall(function() setclipboard(textToCopy) copySuccessful = true end)
        if copySuccessful then showNotification("ƒê√É COPY: " .. textToCopy .. " ‚úÖ") else showNotification("ƒê√É COPY: " .. textToCopy .. " (Th·∫•t b·∫°i)") end -- Th√™m icon
    end)

    BtnToggleAimbot.MouseButton1Click:Connect(function()
        if GUI_CLOSED then return end
        AIMBOT_ENABLED = not AIMBOT_ENABLED
        updateButtonText(BtnToggleAimbot, "Aim", AIMBOT_ENABLED, "üî´")
        showNotification(AIMBOT_ENABLED and "Aim B·∫¨T (Ph√≠m E)" or "Aim T·∫ÆT") -- D·ªãch Notification
    end)

    BtnToggleESP.MouseButton1Click:Connect(function()
        if GUI_CLOSED then return end
        ESP_ENABLED = not ESP_ENABLED
        updateButtonText(BtnToggleESP, "ƒê·ªãnh V·ªã H·ªôp", ESP_ENABLED, "üî≤")
    end)

    BtnToggleESPLines.MouseButton1Click:Connect(function()
        if GUI_CLOSED then return end
        ESPLINE_ENABLED = not ESPLINE_ENABLED
        updateButtonText(BtnToggleESPLines, "ƒê·ªãnh V·ªã ƒê∆∞·ªùng", ESPLINE_ENABLED, "‡πÄ‡∏™‡πâ‡∏ô")
    end)

    BtnToggleFOV.MouseButton1Click:Connect(function()
        if GUI_CLOSED then return end
        FOV_ENABLED = not FOV_ENABLED
        updateButtonText(BtnToggleFOV, "Hi·ªÉn th·ªã FOV", FOV_ENABLED, "‚≠ï")
    end)

    BtnToggleTeamCheck.MouseButton1Click:Connect(function()
        if GUI_CLOSED then return end
        TEAMCHECK_ENABLED = not TEAMCHECK_ENABLED
        updateButtonText(BtnToggleTeamCheck, "B·ªè qua ƒë·ªìng ƒë·ªôi", TEAMCHECK_ENABLED, "ü§ù")
    end)

    -- Event Handler cho Rainbow FOV
    BtnToggleRainbowFOV.MouseButton1Click:Connect(function()
        if GUI_CLOSED then return end
        RAINBOW_FOV_ENABLED = not RAINBOW_FOV_ENABLED
        updateButtonText(BtnToggleRainbowFOV, "Rainbow FOV", RAINBOW_FOV_ENABLED, "üåà")
        showNotification(RAINBOW_FOV_ENABLED and "Rainbow FOV ƒê√£ B·∫≠t" or "Rainbow FOV ƒê√£ T·∫Øt") -- D·ªãch Notification
    end)

    CloseBtn.MouseButton1Click:Connect(function()
        AIMBOT_ENABLED = false
        ESP_ENABLED = false
        ESPLINE_ENABLED = false
        FOV_ENABLED = false
        TEAMCHECK_ENABLED = false
        RAINBOW_FOV_ENABLED = false 
        GUI_CLOSED = true
        ToggleBlur(false)

        if Frame then Frame.Visible = false end
        if ScreenGui then ScreenGui.Enabled = false end

        -- X√≥a t·∫•t c·∫£ c√°c ƒë·ªëi t∆∞·ª£ng Drawing
        if fovCircle then fovCircle.Visible = false end
        for _, esp in pairs(ESPs) do
            if esp.Box then pcall(function() esp.Box:Remove() end) end
            if esp.Line then pcall(function() esp.Line:Remove() end) end
            if esp.IndexText then pcall(function() esp.IndexText:Remove() end) end
            ESPs[plr] = nil
        end
    end)

    -- ƒê·∫∑t ScreenGui v√†o PlayerGui sau khi t·∫•t c·∫£ ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p
    ScreenGui.Parent = PlayerGui
end

buildGUI()

--== INPUT & CHARACTER EVENTS ==--

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if GUI_CLOSED then return end

    if not gameProcessed and input.KeyCode == Enum.KeyCode.E then
        AIMBOT_ENABLED = not AIMBOT_ENABLED
        if BtnToggleAimbot and BtnToggleAimbot.Parent then
            updateButtonText(BtnToggleAimbot, "Aim", AIMBOT_ENABLED, "üî´")
        end
        showNotification(AIMBOT_ENABLED and "Aim B·∫¨T (Ph√≠m E)" or "Aim T·∫ÆT") -- D·ªãch Notification

    elseif not gameProcessed and input.KeyCode == Enum.KeyCode.K then
        if Frame then
            Frame.Visible = not Frame.Visible
            ToggleBlur(Frame.Visible)
        else
            pcall(buildGUI)
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.25)
    Camera = Workspace.CurrentCamera
    Mouse = LocalPlayer:GetMouse()
    PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    if not ScreenGui or not ScreenGui.Parent then
        pcall(buildGUI)
    else
        if ScreenGui.Parent ~= PlayerGui then
            ScreenGui.Parent = PlayerGui
        end
        -- C·∫≠p nh·∫≠t gi√° tr·ªã FOV khi respawn n·∫øu c√≥ fovCircle
        if fovCircle then
            fovCircle.Radius = FOV_RADIUS_VALUE
        end
    end
end)

--== FPS COUNTER SETUP ==--
local lastTick = tick()
RunService.Heartbeat:Connect(function()
    local now = tick()
    local delta = now - lastTick
    lastTick = now
    local fps = math.round(1 / delta)

    if FPSMover and FPSMover.Parent then
        FPSMover.Text = "[FPS: " .. fps .. "]"
    end
end)

--== RENDER LOOP (C·∫¨P NH·∫¨T M√ÄU V√Ä INDEX TEXT V·ªä TR√ç) ==--

-- V·ªã tr√≠ g·ªëc c·ªë ƒë·ªãnh ƒë·ªÉ hi·ªÉn th·ªã Index Text ƒê∆†N L·∫∫
local INDEX_BASE_X = 0 
local INDEX_BASE_Y = 10 
local hue = 0 -- Bi·∫øn l∆∞u tr·ªØ gi√° tr·ªã Hue (0 ƒë·∫øn 1)

RunService.RenderStepped:Connect(function()
    if GUI_CLOSED then
        if fovCircle then fovCircle.Visible = false end
        return
    end

    local visiblePlayerCount = 0
    local targetPlayer = getClosestToFOV() -- L·∫•y m·ª•c ti√™u g·∫ßn FOV nh·∫•t

    if fovCircle and Camera then
        if FOV_ENABLED then
            fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            fovCircle.Radius = FOV_RADIUS_VALUE
            
            -- [RAINBOW FOV LOGIC]
            if RAINBOW_FOV_ENABLED then
                -- C·∫≠p nh·∫≠t Hue (tƒÉng d·∫ßn 0.01 m·ªói khung h√¨nh)
                hue = hue + 0.01 
                if hue > 1 then hue = 0 end
                
                -- √Åp d·ª•ng m√†u c·∫ßu v·ªìng cho FOV Circle
                fovCircle.Color = colorFromHSV(hue, 1, 1) -- S=1 (Saturation), V=1 (Value/Brightness)
            else
                -- Quay v·ªÅ m√†u m·∫∑c ƒë·ªãnh n·∫øu Rainbow t·∫Øt
                fovCircle.Color = FOV_COLOR
            end
            
            fovCircle.Visible = true
        else
            fovCircle.Visible = false
        end
    end

    -- C·∫≠p nh·∫≠t v·ªã tr√≠ X g·ªëc cho Index Text (CƒÉn gi·ªØa)
    INDEX_BASE_X = Camera.ViewportSize.X/2

    for plr, esp in pairs(ESPs) do
        local character = plr.Character
        local shouldShow = ESP_ENABLED or ESPLINE_ENABLED
        
        -- C·ªù x√°c ƒë·ªãnh xem ƒë√¢y c√≥ ph·∫£i ng∆∞·ªùi ch∆°i ƒêANG ƒê∆Ø·ª¢C CH·ªåN ƒë·ªÉ hi·ªÉn th·ªã Index Text kh√¥ng
        local isTargetIndex = false 
        
        if esp and character and character:FindFirstChild("HumanoidRootPart") and Camera and shouldShow then
            local hrp = character.HumanoidRootPart
            local vec, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            
            -- Ki·ªÉm tra xem c√≥ ph·∫£i ƒë·ªìng ƒë·ªôi kh√¥ng
            local isTeamMate = TEAMCHECK_ENABLED and plr.Team and LocalPlayer.Team and plr.Team == LocalPlayer.Team
            
            local current_color
            if isTeamMate then
                current_color = TEAM_COLOR
            else
                current_color = ENEMY_COLOR -- TR·∫ÆNG (Cho Box v√† Line)
            end

            if onScreen then
                visiblePlayerCount = visiblePlayerCount + 1

                -- KI·ªÇM TRA M·ª§C TI√äU INDEX ƒê∆†N L·∫∫
                -- Ch·ªâ hi·ªÉn th·ªã Index Text n·∫øu ng∆∞·ªùi ch∆°i n√†y l√† m·ª•c ti√™u g·∫ßn FOV nh·∫•t V√Ä Aimbot/ESPLINE ƒëang b·∫≠t
                if plr == targetPlayer and (AIMBOT_ENABLED or ESPLINE_ENABLED) then
                    isTargetIndex = true
                    
                    -- INDEX TEXT (Lu√¥n hi·ªÉn th·ªã ·ªü v·ªã tr√≠ c·ªë ƒë·ªãnh, ch·ªâ duy nh·∫•t 1 s·ªë)
                    if esp.IndexText then
                        -- ƒê·∫∑t Index Text c·ªë ƒë·ªãnh ·ªü gi·ªØa tr√™n
                        esp.IndexText.Position = Vector2.new(INDEX_BASE_X - 24, INDEX_BASE_Y) -- X d·ªãch 24px sang tr√°i ƒë·ªÉ cƒÉn gi·ªØa
                        esp.IndexText.Text = "üéØ" -- Bi·ªÉu t∆∞·ª£ng m·ª•c ti√™u
                        esp.IndexText.Color = INDEX_COLOR_ENEMY -- ƒê·ªé
                        esp.IndexText.Visible = true
                    end
                end

                -- ESP BOX
                local topVec = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0,3.5,0))
                local bottomVec = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0,3.5,0))
                local height = math.abs(topVec.Y - bottomVec.Y)

                if ESP_ENABLED then
                    if esp.Box then
                        esp.Box.Size = Vector2.new(height*0.6, height)
                        esp.Box.Position = Vector2.new(vec.X - esp.Box.Size.X/2, vec.Y - esp.Box.Size.Y/2)
                        esp.Box.Color = current_color
                        esp.Box.Visible = true
                    end
                else
                    if esp.Box then esp.Box.Visible = false end
                end

                -- ESP LINES
                if ESPLINE_ENABLED then
                    if esp.Line then
                        -- G·ªëc tia c·ªë ƒë·ªãnh ·ªü gi·ªØa c·∫°nh tr√™n
                        esp.Line.From = Vector2.new(Camera.ViewportSize.X/2, 0)
                        esp.Line.To = Vector2.new(vec.X, vec.Y)
                        esp.Line.Color = current_color
                        esp.Line.Visible = true
                    end
                else
                    if esp.Line then esp.Line.Visible = false end
                end

            else
                -- Khi ng∆∞·ªùi ch∆°i KH√îNG ·ªü tr√™n m√†n h√¨nh
                if esp.Box then esp.Box.Visible = false end
                if esp.Line then esp.Line.Visible = false end
                if esp.IndexText then esp.IndexText.Visible = false end
            end
            
            -- ·∫®N Index Text cho nh·ªØng ng∆∞·ªùi ch∆°i kh√¥ng ph·∫£i l√† m·ª•c ti√™u ch√≠nh
            if esp.IndexText and esp.IndexText.Visible and not isTargetIndex then
                esp.IndexText.Visible = false
            end
            
        else
            -- Khi Character ho·∫∑c Camera kh√¥ng h·ª£p l·ªá
            if esp.Box then esp.Box.Visible = false end
            if esp.Line then esp.Line.Visible = false end
            if esp.IndexText then esp.IndexText.Visible = false end
        end
        
        -- ƒê·∫£m b·∫£o ch·ªâ Index Text c·ªßa m·ª•c ti√™u ch√≠nh m·ªõi hi·ªÉn th·ªã
        if esp.IndexText and esp.IndexText.Visible and not isTargetIndex then
            esp.IndexText.Visible = false
        end
        
    end

    if PlayerCountLabel and Frame and Frame.Visible then
        -- C·∫≠p nh·∫≠t nh√£n ƒë·∫øm ng∆∞·ªùi ch∆°i (ƒê√£ d·ªãch)
        PlayerCountLabel.Text = "Ng∆∞·ªùi ch∆°i hi·ªÉn th·ªã: " .. visiblePlayerCount .. (shouldShow and "" or "")
    end

    if AIMBOT_ENABLED and Camera then
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPlayer.Character.Head.Position)
        end
    end
end)
